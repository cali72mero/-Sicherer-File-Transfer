<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Transfer V14 (Auto-E2EE)</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        body { font-family: -apple-system, sans-serif; background: #eef2f5; padding: 20px; color: #333; max-width: 600px; margin: 0 auto; }
        .card { background: white; padding: 25px; border-radius: 12px; box-shadow: 0 4px 6px rgba(0,0,0,0.05); margin-bottom: 20px; }
        h2 { margin: 0 0 15px 0; color: #2d3748; }
        input { width: 100%; padding: 12px; margin: 8px 0; border: 2px solid #e2e8f0; border-radius: 8px; font-size: 16px; box-sizing: border-box; text-align: center; }
        button { width: 100%; padding: 14px; background: #4299e1; color: white; border: none; border-radius: 8px; font-weight: bold; font-size: 16px; cursor: pointer; margin-top: 5px; }
        button.green { background: #48bb78; }
        button.red { background: #f56565; }
        .hidden { display: none; }
        .status-badge { display: inline-block; padding: 5px 15px; border-radius: 20px; font-size: 13px; font-weight: bold; background: #cbd5e0; color: #4a5568; margin-bottom: 20px; }
        .status-badge.online { background: #c6f6d5; color: #22543d; }
        .status-badge.secure { background: #805ad5; color: white; }
        .pin-display { font-size: 48px; letter-spacing: 10px; font-weight: 800; text-align: center; background: #edf2f7; padding: 20px; border-radius: 10px; margin: 20px 0; color: #2d3748; }
        
        .tools-box { background: #f7fafc; padding: 15px; border-radius: 8px; margin-bottom: 15px; border: 1px solid #e2e8f0; }
        .tool-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        .switch { position: relative; display: inline-block; width: 50px; height: 26px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 34px; }
        input:checked + .slider { background-color: #4299e1; }
        input:checked + .slider:before { transform: translateX(24px); background: white; }
        .slider:before { position: absolute; content: ""; height: 20px; width: 20px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }

        .file-item { padding: 15px; border-bottom: 1px solid #eee; display: flex; justify-content: space-between; align-items: center; background: #fff; margin-top: 5px; border-radius: 8px; border-left: 5px solid #805ad5; }
    </style>
</head>
<body>

    <div style="text-align:center;">
        <h2>üõ°Ô∏è Transfer V14</h2>
        <div id="statusBadge" class="status-badge">Nicht verbunden</div>
    </div>

    <!-- 1. SETUP -->
    <div id="screenSetup" class="card">
        <h2>1. Wer bist du?</h2>
        <input type="text" id="myName" placeholder="Dein Name (z.B. handy)" onkeyup="cleanInput(this)">
        <button onclick="startApp()">Online gehen</button>
    </div>

    <!-- 2. CONNECT -->
    <div id="screenConnect" class="card hidden">
        <p style="text-align:center;">Ich bin: <strong id="dispName" style="color:#4299e1;">...</strong></p>
        <hr style="border:0; border-top:1px solid #eee; margin:20px 0;">
        <h3>Verbinden</h3>
        <input type="text" id="partnerName" placeholder="Name des Partners" onkeyup="cleanInput(this)">
        <button class="green" onclick="connect()" id="btnConn">Verbinden</button>
    </div>

    <!-- 3. AUTH -->
    <div id="screenAuth" class="card hidden">
        <h2 style="text-align:center;">üîí Sicherer Handshake</h2>
        <div id="authReceiver" class="hidden">
            <p style="text-align:center;">PIN f√ºr Partner:</p>
            <div id="pinDisplay" class="pin-display">----</div>
        </div>
        <div id="authSender" class="hidden">
            <p style="text-align:center;">PIN eingeben:</p>
            <input type="tel" id="inputPin" placeholder="0000" maxlength="4" style="font-size:32px; letter-spacing:5px;">
            <button class="green" onclick="submitPin()">Best√§tigen</button>
        </div>
    </div>

    <!-- 4. TRANSFER -->
    <div id="screenTransfer" class="card hidden">
        <h2 style="text-align:center; color:#805ad5;">üîí E2E Verschl√ºsselt</h2>
        
        <div class="tools-box">
            <h4 style="margin:0 0 10px 0;">‚öôÔ∏è Optimierung</h4>
            <div class="tool-row">
                <span>üìâ Bilder komprimieren</span>
                <label class="switch"><input type="checkbox" id="optCompress"><span class="slider"></span></label>
            </div>
            <div class="tool-row">
                <span>‚ú® Quality Boost (Sch√§rfen)</span>
                <label class="switch"><input type="checkbox" id="optBoost"><span class="slider"></span></label>
            </div>
        </div>

        <div style="text-align:center; padding:20px; border:2px dashed #805ad5; background:#faf5ff; border-radius:10px; cursor:pointer;" onclick="document.getElementById('files').click()">
            <strong>üìÇ Dateien w√§hlen</strong>
        </div>
        <input type="file" id="files" multiple style="display:none;" onchange="processAndSend()">
        
        <div id="progress" class="hidden" style="text-align:center; margin-top:10px; color:#666;">Verschl√ºssele...</div>
        <div id="fileList" style="margin-top:20px;"></div>
    </div>

    <script>
        const PREFIX = 'sft-v14-auto-';
        const ICE_SERVERS = [{ urls: 'stun:stun.l.google.com:19302' }];
        
        let peer, conn, myPin, myName;
        let sessionKey = null; // AES-GCM Key for this session

        function cleanInput(el) { el.value = el.value.toLowerCase().replace(/[^a-z0-9]/g, ''); }
        function setStatus(msg, type) { document.getElementById('statusBadge').className = 'status-badge '+type; document.getElementById('statusBadge').innerText = msg; }

        // --- CRYPTO (Diffie-Hellman Sim) ---
        // Since WebCrypto doesn't do DH easily without certs, we use a shared secret derived from the PIN + internal handshake
        // In a real app, use ECDH. Here we derive a session key from the verified PIN + random salts exchanged during handshake.
        // This ensures if you don't know the PIN, you can't derive the key.
        
        async function deriveSessionKey(pin, salt1, salt2) {
            const enc = new TextEncoder();
            const material = await crypto.subtle.importKey(
                "raw", 
                enc.encode(pin + salt1 + salt2), 
                "PBKDF2", 
                false, 
                ["deriveKey"]
            );
            return crypto.subtle.deriveKey(
                { name: "PBKDF2", salt: enc.encode("sft-v14-secure"), iterations: 200000, hash: "SHA-256" },
                material,
                { name: "AES-GCM", length: 256 },
                true, // exportable for debug if needed, but we keep it internal
                ["encrypt", "decrypt"]
            );
        }

        // --- APP ---
        function startApp() {
            myName = document.getElementById('myName').value;
            if (myName.length < 2) return alert("Name zu kurz");
            
            peer = new Peer(PREFIX + myName, { debug: 1, config: { iceServers: ICE_SERVERS } });
            
            peer.on('open', () => {
                setStatus('Online: ' + myName, 'online');
                document.getElementById('screenSetup').classList.add('hidden');
                document.getElementById('screenConnect').classList.remove('hidden');
                document.getElementById('dispName').innerText = myName;
            });
            
            peer.on('connection', (c) => {
                conn = c;
                c.on('open', () => {
                    // Receiver generates PIN and Salt
                    myPin = Math.floor(1000 + Math.random()*9000).toString();
                    const mySalt = Math.random().toString(36).substring(2);
                    conn.mySalt = mySalt; // Store locally
                    
                    document.getElementById('screenConnect').classList.add('hidden');
                    document.getElementById('screenAuth').classList.remove('hidden');
                    document.getElementById('authReceiver').classList.remove('hidden');
                    document.getElementById('pinDisplay').innerText = myPin;
                    
                    c.send({ type: 'HANDSHAKE_INIT', salt: mySalt });
                });
                setupData();
            });
        }

        function connect() {
            const p = document.getElementById('partnerName').value;
            conn = peer.connect(PREFIX + p);
            conn.on('open', setupData);
        }

        function setupData() {
            conn.on('data', async (d) => {
                // 1. Handshake & Key Gen
                if (d.type === 'HANDSHAKE_INIT') {
                    // Sender received Receiver's Salt
                    conn.partnerSalt = d.salt;
                    conn.mySalt = Math.random().toString(36).substring(2); // Sender Salt
                    
                    document.getElementById('screenConnect').classList.add('hidden');
                    document.getElementById('screenAuth').classList.remove('hidden');
                    document.getElementById('authSender').classList.remove('hidden');
                }

                if (d.type === 'PIN_VERIFY') {
                    // Receiver checks PIN
                    if (d.pin === myPin) {
                        conn.partnerSalt = d.salt; // Get Sender Salt
                        // Derive Key
                        sessionKey = await deriveSessionKey(myPin, conn.mySalt, conn.partnerSalt);
                        conn.send({ type: 'AUTH_OK' });
                        showTransfer();
                    } else {
                        conn.send({ type: 'AUTH_FAIL' });
                        alert('Falscher PIN'); location.reload();
                    }
                }

                if (d.type === 'AUTH_OK') {
                    // Sender derives key (needs PIN input value)
                    const p = document.getElementById('inputPin').value;
                    sessionKey = await deriveSessionKey(p, conn.partnerSalt, conn.mySalt);
                    showTransfer();
                }

                // 2. Encrypted Data
                if (d.type === 'ENCRYPTED_FILE') {
                    receiveEncryptedFile(d);
                }
            });
        }

        function submitPin() {
            const p = document.getElementById('inputPin').value;
            // Send PIN + My Salt to Receiver
            conn.send({ type: 'PIN_VERIFY', pin: p, salt: conn.mySalt });
        }

        function showTransfer() {
            document.getElementById('screenAuth').classList.add('hidden');
            document.getElementById('screenTransfer').classList.remove('hidden');
            setStatus('Sicher Verbunden', 'secure');
        }

        // --- SENDING (Auto-Encrypt) ---
        async function processAndSend() {
            const files = document.getElementById('files').files;
            const compress = document.getElementById('optCompress').checked;
            const boost = document.getElementById('optBoost').checked;

            document.getElementById('progress').classList.remove('hidden');

            for (let f of files) {
                let blob = f;
                
                // Image Opt
                if (f.type.startsWith('image/') && (compress || boost)) {
                    try {
                        const bmp = await createImageBitmap(f);
                        const cvs = document.createElement('canvas');
                        cvs.width = bmp.width; cvs.height = bmp.height;
                        const ctx = cvs.getContext('2d');
                        if (boost) {
                            ctx.filter = 'contrast(1.1) saturate(1.1)';
                            ctx.drawImage(bmp,0,0);
                            blob = await new Promise(r=>cvs.toBlob(r,'image/png'));
                        } else {
                            ctx.drawImage(bmp,0,0);
                            blob = await new Promise(r=>cvs.toBlob(r,'image/jpeg',0.6));
                        }
                    } catch(e){}
                }

                // ENCRYPT
                const buffer = await blob.arrayBuffer();
                const iv = crypto.getRandomValues(new Uint8Array(12));
                const encrypted = await crypto.subtle.encrypt(
                    { name: "AES-GCM", iv: iv },
                    sessionKey,
                    buffer
                );

                // Pack: IV + DATA
                conn.send({
                    type: 'ENCRYPTED_FILE',
                    name: f.name,
                    mime: blob.type,
                    iv: iv,
                    data: encrypted
                });
            }
            document.getElementById('progress').classList.add('hidden');
            alert("Verschl√ºsselt gesendet!");
        }

        // --- RECEIVING (Auto-Decrypt) ---
        async function receiveEncryptedFile(d) {
            try {
                // Decrypt
                const decrypted = await crypto.subtle.decrypt(
                    { name: "AES-GCM", iv: new Uint8Array(d.iv) },
                    sessionKey,
                    d.data
                );

                // Display
                const blob = new Blob([decrypted], {type: d.mime});
                const url = URL.createObjectURL(blob);
                
                const div = document.createElement('div');
                div.className = 'file-item';
                div.innerHTML = `
                    <div><strong>${d.name}</strong><br><small>Sicher empfangen</small></div>
                    <a href="${url}" download="${d.name}" style="background:#805ad5; color:white; padding:8px 15px; text-decoration:none; border-radius:5px;">üíæ Speichern</a>
                `;
                document.getElementById('fileList').prepend(div);
                
            } catch (e) {
                console.error(e);
                alert("Entschl√ºsselungs-Fehler! Daten manipuliert?");
            }
        }
    </script>
</body>
</html>
